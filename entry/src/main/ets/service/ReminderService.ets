import { CalendarEvent, ReminderType } from '../model/CalendarEvent';
import { notificationManager } from '@kit.NotificationKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { preferences } from '@kit.ArkData';
import { common } from '@kit.AbilityKit';

// æé†’ç»Ÿè®¡æ¥å£
interface ReminderStats {
  totalReminders: number;
  activeReminders: number;
  upcomingReminders: number;
}

// æ‰¹é‡è®¾ç½®ç»“æœæ¥å£
interface BatchSetResult {
  success: number;
  failed: number;
}

// æé†’æœåŠ¡ç±»ï¼ˆåŸºäºå®šæ—¶å™¨ï¼‰
export class ReminderService {
  private static instance: ReminderService;
  private reminderTimers: Map<string, number> = new Map();
  private preferencesStore: preferences.Preferences | null = null;
  private readonly REMINDERS_KEY = 'reminder_mappings';
  
  private constructor() {}
  
  static getInstance(): ReminderService {
    if (!ReminderService.instance) {
      ReminderService.instance = new ReminderService();
    }
    return ReminderService.instance;
  }
  
  // åˆå§‹åŒ–æé†’æœåŠ¡
  async init(context: common.UIAbilityContext): Promise<void> {
    try {
      // åˆå§‹åŒ–é¦–é€‰é¡¹å­˜å‚¨
      this.preferencesStore = await preferences.getPreferences(context, 'reminder_data');
      await this.loadReminderMappings();
      
      // è¯·æ±‚é€šçŸ¥æƒé™
      await this.requestNotificationPermission(context);
      
      // å‘é€æµ‹è¯•é€šçŸ¥éªŒè¯åŠŸèƒ½
      await this.testNotification();
      
      console.info('æé†’æœåŠ¡åˆå§‹åŒ–æˆåŠŸï¼ˆå®šæ—¶å™¨æ¨¡å¼ï¼‰');
    } catch (error) {
      console.error('åˆå§‹åŒ–æé†’æœåŠ¡å¤±è´¥:', error);
    }
  }
  
  // åŠ è½½æé†’æ˜ å°„å…³ç³»
  private async loadReminderMappings(): Promise<void> {
    try {
      if (!this.preferencesStore) {
        return;
      }
      
      const mappingsJson = await this.preferencesStore.get(this.REMINDERS_KEY, '{}') as string;
      const mappingsData: Record<string, number> = JSON.parse(mappingsJson) as Record<string, number>;
      
      this.reminderTimers.clear();
      const eventIds = Object.keys(mappingsData);
      for (const eventId of eventIds) {
        this.reminderTimers.set(eventId, mappingsData[eventId]);
      }
      
      console.info(`å·²åŠ è½½ ${this.reminderTimers.size} ä¸ªæé†’æ˜ å°„`);
    } catch (error) {
      const err = error as BusinessError;
      console.error(`åŠ è½½æé†’æ˜ å°„å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
      this.reminderTimers.clear();
    }
  }
  
  // ä¿å­˜æé†’æ˜ å°„å…³ç³»
  private async saveReminderMappings(): Promise<void> {
    try {
      if (!this.preferencesStore) {
        return;
      }
      
      const mappingsData: Record<string, number> = {};
      this.reminderTimers.forEach((timerId: number, eventId: string) => {
        mappingsData[eventId] = timerId;
      });
      
      const mappingsJson = JSON.stringify(mappingsData);
      await this.preferencesStore.put(this.REMINDERS_KEY, mappingsJson);
      await this.preferencesStore.flush();
      
      console.info(`å·²ä¿å­˜ ${this.reminderTimers.size} ä¸ªæé†’æ˜ å°„`);
    } catch (error) {
      const err = error as BusinessError;
      console.error(`ä¿å­˜æé†’æ˜ å°„å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
    }
  }
  
  // æµ‹è¯•é€šçŸ¥åŠŸèƒ½
  async testNotification(): Promise<void> {
    try {
      const notificationRequest: notificationManager.NotificationRequest = {
        id: Date.now(),
        content: {
          notificationContentType: notificationManager.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT,
          normal: {
            title: "ğŸ“… æ—¥ç¨‹æé†’æµ‹è¯•",
            text: "é€šçŸ¥ç³»ç»Ÿå·¥ä½œæ­£å¸¸",
            additionalText: "æµ‹è¯•é€šçŸ¥"
          }
        }
      };

      await notificationManager.publish(notificationRequest);
      console.info('âœ… æµ‹è¯•é€šçŸ¥å‘é€æˆåŠŸ');
      
      // æ·»åŠ ä¸€ä¸ª10ç§’åçš„æµ‹è¯•å®šæ—¶å™¨
      setTimeout(() => {
        console.info('ğŸ”” 10ç§’æµ‹è¯•å®šæ—¶å™¨è§¦å‘æˆåŠŸï¼');
        this.sendTestReminderNotification();
      }, 10000);
      
      console.info('â° å·²è®¾ç½®10ç§’åçš„æµ‹è¯•å®šæ—¶å™¨');
      
    } catch (error) {
      const err = error as BusinessError;
      console.error(`âŒ æµ‹è¯•é€šçŸ¥å‘é€å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
    }
  }
  
  // å‘é€æµ‹è¯•æé†’é€šçŸ¥
  private async sendTestReminderNotification(): Promise<void> {
    try {
      const notificationRequest: notificationManager.NotificationRequest = {
        id: Date.now(),
        content: {
          notificationContentType: notificationManager.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT,
          normal: {
            title: "ğŸ”” å®šæ—¶å™¨æµ‹è¯•",
            text: "å®šæ—¶å™¨åŠŸèƒ½æ­£å¸¸å·¥ä½œï¼",
            additionalText: "æµ‹è¯•æé†’"
          }
        }
      };

      await notificationManager.publish(notificationRequest);
      console.info('âœ… æµ‹è¯•å®šæ—¶å™¨æé†’å‘é€æˆåŠŸ');
    } catch (error) {
      const err = error as BusinessError;
      console.error(`âŒ æµ‹è¯•å®šæ—¶å™¨æé†’å‘é€å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
    }
  }
  
  // è¯·æ±‚é€šçŸ¥æƒé™
  private async requestNotificationPermission(context: common.UIAbilityContext): Promise<void> {
    try {
      const isEnabled = await notificationManager.isNotificationEnabled();
      console.info(`é€šçŸ¥æƒé™çŠ¶æ€: ${isEnabled}`);
      
      if (!isEnabled) {
        console.info('è¯·æ±‚é€šçŸ¥æƒé™...');
        try {
          await notificationManager.requestEnableNotification(context);
          console.info('âœ… é€šçŸ¥æƒé™è¯·æ±‚æˆåŠŸ');
        } catch (error) {
          const err = error as BusinessError;
          if (err.code === 1600004) {
            console.warn('âš ï¸ ç”¨æˆ·æ‹’ç»äº†é€šçŸ¥æƒé™');
          } else {
            console.error(`âŒ è¯·æ±‚é€šçŸ¥æƒé™å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
          }
        }
      } else {
        console.info('âœ… é€šçŸ¥æƒé™å·²å¼€å¯');
      }
    } catch (error) {
      const err = error as BusinessError;
      console.error(`æ£€æŸ¥é€šçŸ¥æƒé™å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
    }
  }
  
  // è®¾ç½®äº‹ä»¶æé†’ï¼ˆå®šæ—¶å™¨æ–¹å¼ï¼‰
  async setEventReminder(event: CalendarEvent): Promise<void> {
    try {
      // å…ˆå–æ¶ˆå·²å­˜åœ¨çš„æé†’
      await this.cancelEventReminder(event.id);
      
      if (event.reminder === ReminderType.NONE) {
        console.info(`äº‹ä»¶ ${event.title} ä¸éœ€è¦æé†’`);
        return;
      }
      
      const reminderTime = this.calculateReminderTime(event);
      const now = new Date();
      
      console.info(`è®¾ç½®æé†’ - äº‹ä»¶: ${event.title}, å½“å‰æ—¶é—´: ${now.toLocaleString()}, æé†’æ—¶é—´: ${reminderTime.toLocaleString()}`);
      
      if (reminderTime <= now) {
        console.warn(`äº‹ä»¶ ${event.title} çš„æé†’æ—¶é—´å·²è¿‡ï¼Œä¸è®¾ç½®æé†’`);
        return;
      }
      
      // ä½¿ç”¨å®šæ—¶å™¨ + é€šçŸ¥æ–¹å¼
      const delay = reminderTime.getTime() - now.getTime();
      console.info(`ä½¿ç”¨å®šæ—¶å™¨æ–¹å¼è®¾ç½®æé†’ï¼Œå»¶è¿Ÿ: ${delay}ms (${Math.round(delay/1000)}ç§’)`);
      
      const timerId = setTimeout(async () => {
        try {
          console.info(`â° å®šæ—¶å™¨è§¦å‘ - å‘é€æé†’: ${event.title}`);
          await this.sendReminderNotification(event);
          // æé†’å‘é€åæ¸…ç†æ˜ å°„
          this.reminderTimers.delete(event.id);
          await this.saveReminderMappings();
          console.info(`âœ… æé†’å¤„ç†å®Œæˆå¹¶æ¸…ç†æ˜ å°„: ${event.title}`);
        } catch (error) {
          console.error('å‘é€æé†’é€šçŸ¥å¤±è´¥:', error);
        }
      }, delay);
      
      // ä¿å­˜æé†’æ˜ å°„ - æ³¨æ„ï¼šsetTimeoutè¿”å›çš„æ˜¯NodeJS.Timeoutï¼Œéœ€è¦è½¬æ¢
      const timerIdNumber = Number(timerId);
      this.reminderTimers.set(event.id, timerIdNumber);
      await this.saveReminderMappings();
      
      console.info(`âœ… è®¾ç½®å®šæ—¶å™¨æé†’æˆåŠŸ: ${event.title}, å°†åœ¨ ${Math.round(delay/1000)}ç§’ åè§¦å‘, å®šæ—¶å™¨ID: ${timerIdNumber}`);
      
    } catch (error) {
      const err = error as BusinessError;
      console.error(`âŒ è®¾ç½®æé†’å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
      throw new Error(`è®¾ç½®æé†’å¤±è´¥: ${err.message}`);
    }
  }
  
  // å‘é€æé†’é€šçŸ¥
  private async sendReminderNotification(event: CalendarEvent): Promise<void> {
    try {
      const notificationRequest: notificationManager.NotificationRequest = {
        id: this.generateNotificationId(event.id),
        content: {
          notificationContentType: notificationManager.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT,
          normal: {
            title: `ğŸ“… ${event.title}`,
            text: this.generateReminderContent(event),
            additionalText: "æ—¥ç¨‹æé†’"
          }
        }
      };

      await notificationManager.publish(notificationRequest);
      console.info(`âœ… æé†’é€šçŸ¥å‘é€æˆåŠŸ: ${event.title}`);
    } catch (error) {
      const err = error as BusinessError;
      console.error(`âŒ å‘é€æé†’é€šçŸ¥å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
    }
  }
  
  // å–æ¶ˆäº‹ä»¶æé†’
  async cancelEventReminder(eventId: string): Promise<void> {
    try {
      const timerId = this.reminderTimers.get(eventId);
      if (timerId !== undefined) {
        clearTimeout(timerId);
        this.reminderTimers.delete(eventId);
        await this.saveReminderMappings();
        console.info(`âœ… å–æ¶ˆå®šæ—¶å™¨æé†’æˆåŠŸ: äº‹ä»¶ID ${eventId}`);
      } else {
        console.warn(`âš ï¸ æœªæ‰¾åˆ°äº‹ä»¶ ${eventId} çš„å®šæ—¶å™¨ID`);
      }
    } catch (error) {
      const err = error as BusinessError;
      console.error(`âŒ å–æ¶ˆæé†’å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
      this.reminderTimers.delete(eventId);
      await this.saveReminderMappings();
    }
  }
  
  // è®¡ç®—æé†’æ—¶é—´
  private calculateReminderTime(event: CalendarEvent): Date {
    const eventTime = new Date(event.startTime);
    const reminderTime = new Date(eventTime);
    
    switch (event.reminder) {
      case ReminderType.AT_TIME:
        break;
      case ReminderType.FIVE_MINUTES:
        reminderTime.setMinutes(reminderTime.getMinutes() - 5);
        break;
      case ReminderType.TEN_MINUTES:
        reminderTime.setMinutes(reminderTime.getMinutes() - 10);
        break;
      case ReminderType.FIFTEEN_MINUTES:
        reminderTime.setMinutes(reminderTime.getMinutes() - 15);
        break;
      case ReminderType.THIRTY_MINUTES:
        reminderTime.setMinutes(reminderTime.getMinutes() - 30);
        break;
      case ReminderType.ONE_HOUR:
        reminderTime.setHours(reminderTime.getHours() - 1);
        break;
      case ReminderType.ONE_DAY:
        reminderTime.setDate(reminderTime.getDate() - 1);
        break;
      default:
        console.warn(`æœªçŸ¥çš„æé†’ç±»å‹: ${event.reminder}`);
        break;
    }
    
    return reminderTime;
  }
  
  // ç”Ÿæˆæé†’å†…å®¹
  private generateReminderContent(event: CalendarEvent): string {
    const startTime = new Date(event.startTime);
    const timeStr = startTime.toLocaleTimeString('zh-CN', { 
      hour: '2-digit', 
      minute: '2-digit' 
    });
    
    let content = `æ—¶é—´: ${timeStr}`;
    
    if (event.description && event.description.trim()) {
      content += `\næè¿°: ${event.description}`;
    }
    
    const reminderTypeText = this.getReminderTypeText(event.reminder);
    if (reminderTypeText !== 'å‡†æ—¶') {
      content += `\næé†’: ${reminderTypeText}`;
    }
    
    return content;
  }
  
  // è·å–æé†’ç±»å‹æ–‡æœ¬
  private getReminderTypeText(reminderType: ReminderType): string {
    switch (reminderType) {
      case ReminderType.AT_TIME: return 'å‡†æ—¶';
      case ReminderType.FIVE_MINUTES: return '5åˆ†é’Ÿå‰';
      case ReminderType.TEN_MINUTES: return '10åˆ†é’Ÿå‰';
      case ReminderType.FIFTEEN_MINUTES: return '15åˆ†é’Ÿå‰';
      case ReminderType.THIRTY_MINUTES: return '30åˆ†é’Ÿå‰';
      case ReminderType.ONE_HOUR: return '1å°æ—¶å‰';
      case ReminderType.ONE_DAY: return '1å¤©å‰';
      default: return 'æœªçŸ¥';
    }
  }
  
  // ç”Ÿæˆé€šçŸ¥ID
  private generateNotificationId(eventId: string): number {
    let hash = 0;
    for (let i = 0; i < eventId.length; i++) {
      const char = eventId.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash) % 1000000;
  }
  
  // è·å–æé†’ç»Ÿè®¡ä¿¡æ¯
  async getReminderStats(): Promise<ReminderStats> {
    return {
      totalReminders: this.reminderTimers.size,
      activeReminders: this.reminderTimers.size,
      upcomingReminders: 0
    } as ReminderStats;
  }
  
  // æ¸…ç†è¿‡æœŸçš„æé†’
  async cleanupExpiredReminders(): Promise<number> {
    return 0;
  }
  
  // å–æ¶ˆæ‰€æœ‰æé†’
  async cancelAllReminders(): Promise<void> {
    this.reminderTimers.forEach((timerId: number) => {
      clearTimeout(timerId);
    });
    
    this.reminderTimers.clear();
    await this.saveReminderMappings();
    console.info('âœ… å–æ¶ˆæ‰€æœ‰å®šæ—¶å™¨æé†’æˆåŠŸ');
  }
  
  // æ£€æŸ¥æé†’æƒé™
  async checkReminderPermission(): Promise<boolean> {
    try {
      const isNotificationEnabled = await notificationManager.isNotificationEnabled();
      return isNotificationEnabled;
    } catch (error) {
      return false;
    }
  }
  
  // æ‰¹é‡è®¾ç½®æé†’
  async batchSetReminders(events: CalendarEvent[]): Promise<BatchSetResult> {
    let successCount = 0;
    let failedCount = 0;
    
    for (const event of events) {
      try {
        await this.setEventReminder(event);
        successCount++;
      } catch (error) {
        failedCount++;
      }
    }
    
    return { success: successCount, failed: failedCount } as BatchSetResult;
  }
}