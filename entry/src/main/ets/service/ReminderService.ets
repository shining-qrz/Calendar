import { CalendarEvent, ReminderType } from '../model/CalendarEvent';
import { reminderAgentManager } from '@kit.BackgroundTasksKit';
import { notificationManager } from '@kit.NotificationKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { preferences } from '@kit.ArkData';
import { common } from '@kit.AbilityKit';

// æé†’ä¿¡æ¯æ¥å£
interface ReminderInfo {
  eventId: string;
  reminderId: number;
  reminderTime: Date;
  eventTitle: string;
}

// æé†’ç»Ÿè®¡æ¥å£
interface ReminderStats {
  totalReminders: number;
  activeReminders: number;
  upcomingReminders: number;
}

// æ‰¹é‡è®¾ç½®ç»“æœæ¥å£
interface BatchSetResult {
  success: number;
  failed: number;
}

// æé†’æœåŠ¡ç±»
export class ReminderService {
  private static instance: ReminderService;
  private reminderIds: Map<string, number> = new Map();
  private preferencesStore: preferences.Preferences | null = null;
  private readonly REMINDERS_KEY = 'reminder_mappings';
  
  private constructor() {}
  
  static getInstance(): ReminderService {
    if (!ReminderService.instance) {
      ReminderService.instance = new ReminderService();
    }
    return ReminderService.instance;
  }
  
  // åˆå§‹åŒ–æé†’æœåŠ¡
  async init(context: common.UIAbilityContext): Promise<void> {
    try {
      // åˆå§‹åŒ–é¦–é€‰é¡¹å­˜å‚¨
      this.preferencesStore = await preferences.getPreferences(context, 'reminder_data');
      await this.loadReminderMappings();
      
      // åˆ›å»ºé€šçŸ¥æ¸ é“
      await this.createNotificationSlot();
      
      // è¯·æ±‚é€šçŸ¥æƒé™
      await this.requestNotificationPermission(context);
      
      // è¯·æ±‚ä»£ç†æé†’æƒé™
      await this.requestReminderPermission(context);
      
      // å‘é€æµ‹è¯•é€šçŸ¥éªŒè¯åŠŸèƒ½
      await this.testNotification();
      
      // å…ˆæ¸…ç†æ‰€æœ‰æé†’ï¼Œè§£å†³æ•°é‡é™åˆ¶é—®é¢˜
      await this.cancelAllReminders();
      
      // æ¸…ç†è¿‡æœŸçš„æé†’
      await this.cleanupExpiredReminders();
      
      console.info('æé†’æœåŠ¡åˆå§‹åŒ–æˆåŠŸ');
    } catch (error) {
      console.error('åˆå§‹åŒ–æé†’æœåŠ¡å¤±è´¥:', error);
    }
  }
  
  // è¯·æ±‚ä»£ç†æé†’æƒé™
  private async requestReminderPermission(context: common.UIAbilityContext): Promise<void> {
    try {
      // æ£€æŸ¥ä»£ç†æé†’æƒé™
      console.info('æ£€æŸ¥ä»£ç†æé†’æƒé™...');
      
      // å°è¯•è·å–æœ‰æ•ˆæé†’æ¥æµ‹è¯•æƒé™
      try {
        const reminders = await reminderAgentManager.getValidReminders();
        console.info(`âœ… ä»£ç†æé†’æƒé™æ­£å¸¸ï¼Œå½“å‰æœ‰ ${reminders.length} ä¸ªæé†’`);
      } catch (error) {
        const err = error as BusinessError;
        console.error(`âŒ ä»£ç†æé†’æƒé™æ£€æŸ¥å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
        
        if (err.code === 201) {
          console.error('âŒ ç¼ºå°‘ä»£ç†æé†’æƒé™ï¼Œè¯·åœ¨è®¾ç½®ä¸­æ‰‹åŠ¨å¼€å¯');
        } else if (err.code === 202) {
          console.error('âŒ ä»£ç†æé†’æƒé™è¢«æ‹’ç»');
        }
      }
    } catch (error) {
      const err = error as BusinessError;
      console.error(`æ£€æŸ¥ä»£ç†æé†’æƒé™å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
    }
  }
  
  // åŠ è½½æé†’æ˜ å°„å…³ç³»
  private async loadReminderMappings(): Promise<void> {
    try {
      if (!this.preferencesStore) {
        return;
      }
      
      const mappingsJson = await this.preferencesStore.get(this.REMINDERS_KEY, '{}') as string;
      const mappingsData: Record<string, number> = JSON.parse(mappingsJson) as Record<string, number>;
      
      this.reminderIds.clear();
      const eventIds = Object.keys(mappingsData);
      for (const eventId of eventIds) {
        this.reminderIds.set(eventId, mappingsData[eventId]);
      }
      
      console.info(`å·²åŠ è½½ ${this.reminderIds.size} ä¸ªæé†’æ˜ å°„`);
    } catch (error) {
      const err = error as BusinessError;
      console.error(`åŠ è½½æé†’æ˜ å°„å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
      this.reminderIds.clear();
    }
  }
  
  // ä¿å­˜æé†’æ˜ å°„å…³ç³»
  private async saveReminderMappings(): Promise<void> {
    try {
      if (!this.preferencesStore) {
        return;
      }
      
      const mappingsData: Record<string, number> = {};
      this.reminderIds.forEach((reminderId: number, eventId: string) => {
        mappingsData[eventId] = reminderId;
      });
      
      const mappingsJson = JSON.stringify(mappingsData);
      await this.preferencesStore.put(this.REMINDERS_KEY, mappingsJson);
      await this.preferencesStore.flush();
      
      console.info(`å·²ä¿å­˜ ${this.reminderIds.size} ä¸ªæé†’æ˜ å°„`);
    } catch (error) {
      const err = error as BusinessError;
      console.error(`ä¿å­˜æé†’æ˜ å°„å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
    }
  }
  
  // æµ‹è¯•ç«‹å³æé†’ï¼ˆç”¨äºè°ƒè¯•ï¼‰
  async testImmediateReminder(): Promise<void> {
    try {
      const now = new Date();
      const testTime = new Date(now.getTime() + 30 * 1000); // 30ç§’å
      
      const reminderRequest: reminderAgentManager.ReminderRequestCalendar = {
        reminderType: reminderAgentManager.ReminderType.REMINDER_TYPE_CALENDAR,
        dateTime: {
          year: testTime.getFullYear(),
          month: testTime.getMonth() + 1,
          day: testTime.getDate(),
          hour: testTime.getHours(),
          minute: testTime.getMinutes(),
          second: testTime.getSeconds()
        },
        title: `ğŸ”” æµ‹è¯•æé†’`,
        content: `è¿™æ˜¯ä¸€ä¸ª30ç§’åçš„æµ‹è¯•æé†’ - ${testTime.toLocaleString()}`,
        notificationId: Date.now(),
        repeatMonths: [],
        repeatDays: [],
        daysOfWeek: []
      };
      
      console.info('æµ‹è¯•æé†’é…ç½®:', JSON.stringify(reminderRequest, null, 2));
      
      const reminderId = await reminderAgentManager.publishReminder(reminderRequest);
      console.info(`âœ… æµ‹è¯•æé†’è®¾ç½®æˆåŠŸï¼ŒID: ${reminderId}, å°†åœ¨30ç§’åè§¦å‘`);
      
    } catch (error) {
      const err = error as BusinessError;
      console.error(`âŒ æµ‹è¯•æé†’å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
    }
  }
  
  // æµ‹è¯•é€šçŸ¥åŠŸèƒ½ï¼ˆç”¨äºéªŒè¯é€šçŸ¥ç³»ç»Ÿï¼‰
  async testNotification(): Promise<void> {
    try {
      const notificationRequest: notificationManager.NotificationRequest = {
        id: Date.now(), // ä½¿ç”¨æ—¶é—´æˆ³ä½œä¸ºå”¯ä¸€ID
        content: {
          notificationContentType: notificationManager.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT,
          normal: {
            title: "ğŸ“… æ—¥ç¨‹æé†’æµ‹è¯•",
            text: "é€šçŸ¥ç³»ç»Ÿå·¥ä½œæ­£å¸¸",
            additionalText: "æµ‹è¯•é€šçŸ¥"
          }
        }
      };

      await notificationManager.publish(notificationRequest);
      console.info('âœ… æµ‹è¯•é€šçŸ¥å‘é€æˆåŠŸ');
    } catch (error) {
      const err = error as BusinessError;
      console.error(`âŒ æµ‹è¯•é€šçŸ¥å‘é€å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
    }
  }
  
  // åˆ›å»ºé€šçŸ¥æ¸ é“ï¼ˆAPI 21ä¸­å¯èƒ½ä¸éœ€è¦æ˜¾å¼åˆ›å»ºé€šçŸ¥æ§½ï¼‰
  private async createNotificationSlot(): Promise<void> {
    try {
      // åœ¨API 21ä¸­ï¼Œé€šçŸ¥æ§½å¯èƒ½æ˜¯è‡ªåŠ¨ç®¡ç†çš„
      // æˆ‘ä»¬åªéœ€è¦ç¡®ä¿é€šçŸ¥æƒé™å·²å¼€å¯
      console.info('âœ… é€šçŸ¥æ¸ é“å‡†å¤‡å®Œæˆï¼ˆAPI 21è‡ªåŠ¨ç®¡ç†ï¼‰');
    } catch (error) {
      const err = error as BusinessError;
      console.error(`âŒ é€šçŸ¥æ¸ é“å‡†å¤‡å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
    }
  }
  
  // è¯·æ±‚é€šçŸ¥æƒé™
  private async requestNotificationPermission(context: common.UIAbilityContext): Promise<void> {
    try {
      // æ£€æŸ¥æ˜¯å¦å·²æœ‰é€šçŸ¥æƒé™
      const isEnabled = await notificationManager.isNotificationEnabled();
      console.info(`é€šçŸ¥æƒé™çŠ¶æ€: ${isEnabled}`);
      
      if (!isEnabled) {
        console.info('è¯·æ±‚é€šçŸ¥æƒé™...');
        try {
          await notificationManager.requestEnableNotification(context);
          console.info('âœ… é€šçŸ¥æƒé™è¯·æ±‚æˆåŠŸ');
        } catch (error) {
          const err = error as BusinessError;
          if (err.code === 1600004) {
            console.warn('âš ï¸ ç”¨æˆ·æ‹’ç»äº†é€šçŸ¥æƒé™');
          } else {
            console.error(`âŒ è¯·æ±‚é€šçŸ¥æƒé™å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
          }
        }
      } else {
        console.info('âœ… é€šçŸ¥æƒé™å·²å¼€å¯');
      }
    } catch (error) {
      const err = error as BusinessError;
      console.error(`æ£€æŸ¥é€šçŸ¥æƒé™å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
    }
  }
  
  // æ£€æŸ¥å¹¶ç®¡ç†æé†’æ•°é‡é™åˆ¶
  private async manageReminderLimit(): Promise<void> {
    try {
      const validReminders = await this.getValidReminders();
      console.info(`å½“å‰ç³»ç»Ÿä¸­æœ‰ ${validReminders.length} ä¸ªæœ‰æ•ˆæé†’`);
      
      // å¦‚æœæé†’æ•°é‡æ¥è¿‘é™åˆ¶ï¼ˆå‡è®¾é™åˆ¶æ˜¯30ä¸ªï¼‰ï¼Œæ¸…ç†ä¸€äº›æ—§çš„
      if (validReminders.length >= 25) {
        console.warn('æé†’æ•°é‡æ¥è¿‘é™åˆ¶ï¼Œå¼€å§‹æ¸…ç†æ—§æé†’');
        
        // æ¸…ç†æ‰€æœ‰æé†’ï¼Œé‡æ–°å¼€å§‹
        await this.cancelAllReminders();
        console.info('å·²æ¸…ç†æ‰€æœ‰æ—§æé†’');
      }
    } catch (error) {
      const err = error as BusinessError;
      console.error(`ç®¡ç†æé†’é™åˆ¶å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
    }
  }
  
  // è®¾ç½®äº‹ä»¶æé†’ï¼ˆæ··åˆæé†’æ–¹æ¡ˆï¼‰
  async setEventReminder(event: CalendarEvent): Promise<void> {
    try {
      // å…ˆå–æ¶ˆå·²å­˜åœ¨çš„æé†’
      await this.cancelEventReminder(event.id);
      
      if (event.reminder === ReminderType.NONE) {
        console.info(`äº‹ä»¶ ${event.title} ä¸éœ€è¦æé†’`);
        return;
      }
      
      const reminderTime = this.calculateReminderTime(event);
      const now = new Date();
      
      console.info(`è®¾ç½®æé†’ - äº‹ä»¶: ${event.title}, å½“å‰æ—¶é—´: ${now.toLocaleString()}, æé†’æ—¶é—´: ${reminderTime.toLocaleString()}`);
      
      if (reminderTime <= now) {
        console.warn(`äº‹ä»¶ ${event.title} çš„æé†’æ—¶é—´å·²è¿‡ï¼Œä¸è®¾ç½®æé†’`);
        return;
      }
      
      // æ£€æŸ¥æƒé™çŠ¶æ€
      const hasPermission = await this.checkReminderPermission();
      if (!hasPermission) {
        console.error('âŒ æé†’æƒé™æœªå¼€å¯ï¼Œæ— æ³•è®¾ç½®æé†’');
        throw new Error('æé†’æƒé™æœªå¼€å¯');
      }
      
      // å°è¯•ä½¿ç”¨ç®€å•çš„å®šæ—¶å™¨ + é€šçŸ¥æ–¹å¼
      const delay = reminderTime.getTime() - now.getTime();
      if (delay > 0 && delay < 24 * 60 * 60 * 1000) { // 24å°æ—¶å†…
        console.info(`ä½¿ç”¨å®šæ—¶å™¨æ–¹å¼è®¾ç½®æé†’ï¼Œå»¶è¿Ÿ: ${delay}ms`);
        
        setTimeout(async () => {
          try {
            await this.sendReminderNotification(event);
          } catch (error) {
            console.error('å‘é€æé†’é€šçŸ¥å¤±è´¥:', error);
          }
        }, delay);
        
        // ä¿å­˜æé†’æ˜ å°„ï¼ˆä½¿ç”¨è´Ÿæ•°è¡¨ç¤ºå®šæ—¶å™¨æé†’ï¼‰
        this.reminderIds.set(event.id, -Date.now());
        await this.saveReminderMappings();
        
        console.info(`âœ… è®¾ç½®å®šæ—¶å™¨æé†’æˆåŠŸ: ${event.title}, å°†åœ¨ ${delay}ms åè§¦å‘`);
        return;
      }
      
      // å¦‚æœè¶…è¿‡24å°æ—¶ï¼Œä½¿ç”¨ç³»ç»Ÿæé†’æ–¹å¼
      console.info('ä½¿ç”¨ç³»ç»Ÿä»£ç†æé†’æ–¹å¼');
      
      // æ ¹æ®API 21åˆ›å»ºç³»ç»Ÿçº§ä»£ç†æé†’è¯·æ±‚ï¼ˆä½¿ç”¨Calendarç±»å‹ï¼‰
      const reminderRequest: reminderAgentManager.ReminderRequestCalendar = {
        reminderType: reminderAgentManager.ReminderType.REMINDER_TYPE_CALENDAR,
        dateTime: {
          year: reminderTime.getFullYear(),
          month: reminderTime.getMonth() + 1,
          day: reminderTime.getDate(),
          hour: reminderTime.getHours(),
          minute: reminderTime.getMinutes(),
          second: 0
        },
        // æé†’å†…å®¹
        title: `ğŸ“… ${event.title}`,
        content: this.generateReminderContent(event),
        // é€šçŸ¥ç›¸å…³è®¾ç½®
        notificationId: this.generateNotificationId(event.id),
        // æ·»åŠ é‡å¤è®¾ç½®ç¡®ä¿æé†’è§¦å‘
        repeatMonths: [],
        repeatDays: [],
        daysOfWeek: []
      };
      
      console.info('æé†’è¯·æ±‚é…ç½®:', JSON.stringify(reminderRequest, null, 2));
      
      const reminderId: number = await reminderAgentManager.publishReminder(reminderRequest);
      this.reminderIds.set(event.id, reminderId);
      await this.saveReminderMappings();
      
      console.info(`âœ… è®¾ç½®ç³»ç»Ÿæé†’æˆåŠŸ: ${event.title}, æé†’æ—¶é—´: ${reminderTime.toLocaleString()}, æé†’ID: ${reminderId}`);
      
    } catch (error) {
      const err = error as BusinessError;
      console.error(`âŒ è®¾ç½®æé†’å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
      
      // å¦‚æœç³»ç»Ÿæé†’å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨å®šæ—¶å™¨æ–¹å¼ä½œä¸ºå¤‡é€‰
      if (err.code === 1700002) {
        console.warn('ç³»ç»Ÿæé†’å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨å®šæ—¶å™¨å¤‡é€‰æ–¹æ¡ˆ');
        try {
          const reminderTime = this.calculateReminderTime(event);
          const now = new Date();
          const delay = reminderTime.getTime() - now.getTime();
          
          if (delay > 0 && delay < 24 * 60 * 60 * 1000) {
            setTimeout(async () => {
              try {
                await this.sendReminderNotification(event);
              } catch (notifyError) {
                console.error('å‘é€å¤‡é€‰æé†’é€šçŸ¥å¤±è´¥:', notifyError);
              }
            }, delay);
            
            this.reminderIds.set(event.id, -Date.now());
            await this.saveReminderMappings();
            
            console.info(`âœ… è®¾ç½®å¤‡é€‰å®šæ—¶å™¨æé†’æˆåŠŸ: ${event.title}`);
            return;
          }
        } catch (fallbackError) {
          console.error('å¤‡é€‰æ–¹æ¡ˆä¹Ÿå¤±è´¥:', fallbackError);
        }
      }
      
      throw new Error(`è®¾ç½®æé†’å¤±è´¥: ${err.message}`);
    }
  }
  
  // å‘é€æé†’é€šçŸ¥
  private async sendReminderNotification(event: CalendarEvent): Promise<void> {
    try {
      const notificationRequest: notificationManager.NotificationRequest = {
        id: this.generateNotificationId(event.id),
        content: {
          notificationContentType: notificationManager.ContentType.NOTIFICATION_CONTENT_BASIC_TEXT,
          normal: {
            title: `ğŸ“… ${event.title}`,
            text: this.generateReminderContent(event),
            additionalText: "æ—¥ç¨‹æé†’"
          }
        }
      };

      await notificationManager.publish(notificationRequest);
      console.info(`âœ… æé†’é€šçŸ¥å‘é€æˆåŠŸ: ${event.title}`);
    } catch (error) {
      const err = error as BusinessError;
      console.error(`âŒ å‘é€æé†’é€šçŸ¥å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
    }
  }
  
  // éªŒè¯æé†’æ˜¯å¦æˆåŠŸåˆ›å»º
  private async verifyReminderCreated(reminderId: number, eventTitle: string): Promise<void> {
    try {
      const validReminders = await this.getValidReminders();
      const foundReminder = validReminders.find(r => {
        // ç”±äºAPIé™åˆ¶ï¼Œæˆ‘ä»¬é€šè¿‡æ ‡é¢˜æ¥éªŒè¯
        return r.title && r.title.includes(eventTitle);
      });
      
      if (foundReminder) {
        console.info(`âœ… æé†’éªŒè¯æˆåŠŸ: ${eventTitle} (ID: ${reminderId})`);
      } else {
        console.warn(`âš ï¸ æé†’éªŒè¯å¤±è´¥: æœªæ‰¾åˆ° ${eventTitle} çš„æé†’`);
      }
      
      console.info(`å½“å‰ç³»ç»Ÿä¸­å…±æœ‰ ${validReminders.length} ä¸ªæœ‰æ•ˆæé†’`);
    } catch (error) {
      const err = error as BusinessError;
      console.error(`éªŒè¯æé†’å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
    }
  }
  async cancelEventReminder(eventId: string): Promise<void> {
    try {
      const reminderId = this.reminderIds.get(eventId);
      if (reminderId !== undefined) {
        await reminderAgentManager.cancelReminder(reminderId);
        this.reminderIds.delete(eventId);
        await this.saveReminderMappings();
        console.info(`âœ… å–æ¶ˆæé†’æˆåŠŸ: äº‹ä»¶ID ${eventId}, æé†’ID ${reminderId}`);
      } else {
        console.warn(`âš ï¸ æœªæ‰¾åˆ°äº‹ä»¶ ${eventId} çš„æé†’ID`);
      }
    } catch (error) {
      const err = error as BusinessError;
      console.error(`âŒ å–æ¶ˆæé†’å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
      // å³ä½¿å–æ¶ˆå¤±è´¥ï¼Œä¹Ÿè¦ä»æ˜ å°„ä¸­ç§»é™¤
      this.reminderIds.delete(eventId);
      await this.saveReminderMappings();
    }
  }
  
  // è®¡ç®—æé†’æ—¶é—´
  private calculateReminderTime(event: CalendarEvent): Date {
    const eventTime = new Date(event.startTime);
    const reminderTime = new Date(eventTime);
    
    switch (event.reminder) {
      case ReminderType.AT_TIME:
        // å‡†æ—¶æé†’
        break;
      case ReminderType.FIVE_MINUTES:
        reminderTime.setMinutes(reminderTime.getMinutes() - 5);
        break;
      case ReminderType.TEN_MINUTES:
        reminderTime.setMinutes(reminderTime.getMinutes() - 10);
        break;
      case ReminderType.FIFTEEN_MINUTES:
        reminderTime.setMinutes(reminderTime.getMinutes() - 15);
        break;
      case ReminderType.THIRTY_MINUTES:
        reminderTime.setMinutes(reminderTime.getMinutes() - 30);
        break;
      case ReminderType.ONE_HOUR:
        reminderTime.setHours(reminderTime.getHours() - 1);
        break;
      case ReminderType.ONE_DAY:
        reminderTime.setDate(reminderTime.getDate() - 1);
        break;
      default:
        console.warn(`æœªçŸ¥çš„æé†’ç±»å‹: ${event.reminder}`);
        break;
    }
    
    return reminderTime;
  }
  
  // ç”Ÿæˆæé†’å†…å®¹
  private generateReminderContent(event: CalendarEvent): string {
    const startTime = new Date(event.startTime);
    const timeStr = startTime.toLocaleTimeString('zh-CN', { 
      hour: '2-digit', 
      minute: '2-digit' 
    });
    
    let content = `æ—¶é—´: ${timeStr}`;
    
    if (event.description && event.description.trim()) {
      content += `\næè¿°: ${event.description}`;
    }
    
    // æ·»åŠ æé†’ç±»å‹è¯´æ˜
    const reminderTypeText = this.getReminderTypeText(event.reminder);
    if (reminderTypeText !== 'å‡†æ—¶') {
      content += `\næé†’: ${reminderTypeText}`;
    }
    
    return content;
  }
  
  // è·å–æé†’ç±»å‹æ–‡æœ¬
  private getReminderTypeText(reminderType: ReminderType): string {
    switch (reminderType) {
      case ReminderType.AT_TIME: return 'å‡†æ—¶';
      case ReminderType.FIVE_MINUTES: return '5åˆ†é’Ÿå‰';
      case ReminderType.TEN_MINUTES: return '10åˆ†é’Ÿå‰';
      case ReminderType.FIFTEEN_MINUTES: return '15åˆ†é’Ÿå‰';
      case ReminderType.THIRTY_MINUTES: return '30åˆ†é’Ÿå‰';
      case ReminderType.ONE_HOUR: return '1å°æ—¶å‰';
      case ReminderType.ONE_DAY: return '1å¤©å‰';
      default: return 'æœªçŸ¥';
    }
  }
  
  // ç”Ÿæˆé€šçŸ¥ID
  private generateNotificationId(eventId: string): number {
    // ä½¿ç”¨äº‹ä»¶IDçš„å“ˆå¸Œå€¼ä½œä¸ºé€šçŸ¥ID
    let hash = 0;
    for (let i = 0; i < eventId.length; i++) {
      const char = eventId.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
    }
    return Math.abs(hash) % 1000000; // é™åˆ¶åœ¨6ä½æ•°å†…
  }
  
  // è·å–æ‰€æœ‰æœ‰æ•ˆçš„æé†’
  async getValidReminders(): Promise<Array<reminderAgentManager.ReminderRequest>> {
    try {
      const reminders = await reminderAgentManager.getValidReminders();
      console.info(`å½“å‰ç³»ç»Ÿä¸­æœ‰ ${reminders.length} ä¸ªæœ‰æ•ˆæé†’`);
      return reminders;
    } catch (error) {
      const err = error as BusinessError;
      console.error(`è·å–æœ‰æ•ˆæé†’å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
      return [];
    }
  }
  
  // è·å–æé†’ç»Ÿè®¡ä¿¡æ¯
  async getReminderStats(): Promise<ReminderStats> {
    try {
      const validReminders = await this.getValidReminders();
      const now = new Date();
      const nextHour = new Date(now.getTime() + 60 * 60 * 1000);
      
      let upcomingCount = 0;
      for (const reminder of validReminders) {
        if (reminder.reminderType === reminderAgentManager.ReminderType.REMINDER_TYPE_CALENDAR) {
          const calendarReminder = reminder as reminderAgentManager.ReminderRequestCalendar;
          if (calendarReminder.dateTime) {
            const reminderTime = new Date(
              calendarReminder.dateTime.year || 0,
              (calendarReminder.dateTime.month || 1) - 1,
              calendarReminder.dateTime.day || 1,
              calendarReminder.dateTime.hour || 0,
              calendarReminder.dateTime.minute || 0
            );
            
            if (reminderTime >= now && reminderTime <= nextHour) {
              upcomingCount++;
            }
          }
        }
      }
      
      return {
        totalReminders: this.reminderIds.size,
        activeReminders: validReminders.length,
        upcomingReminders: upcomingCount
      } as ReminderStats;
    } catch (error) {
      const err = error as BusinessError;
      console.error(`è·å–æé†’ç»Ÿè®¡å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
      return {
        totalReminders: 0,
        activeReminders: 0,
        upcomingReminders: 0
      } as ReminderStats;
    }
  }
  
  // æ¸…ç†è¿‡æœŸçš„æé†’
  async cleanupExpiredReminders(): Promise<number> {
    try {
      const validReminders = await this.getValidReminders();
      // ç®€åŒ–å®ç°ï¼šç›´æ¥æ¸…ç†æ‰€æœ‰æ˜ å°„ä¸­ä¸å­˜åœ¨çš„æé†’ID
      const toRemove: string[] = [];
      
      // ç”±äºAPIé™åˆ¶ï¼Œæš‚æ—¶è·³è¿‡è¯¦ç»†çš„IDåŒ¹é…ï¼Œç›´æ¥è¿›è¡ŒåŸºæœ¬æ¸…ç†
      this.reminderIds.forEach((reminderId: number, eventId: string) => {
        // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´å¤šçš„éªŒè¯é€»è¾‘
        // æš‚æ—¶ä¿ç•™æ‰€æœ‰æ˜ å°„
      });
      
      let cleanedCount = 0;
      
      // ç§»é™¤æ— æ•ˆçš„æ˜ å°„
      for (const eventId of toRemove) {
        this.reminderIds.delete(eventId);
        cleanedCount++;
      }
      
      if (cleanedCount > 0) {
        await this.saveReminderMappings();
        console.info(`æ¸…ç†äº† ${cleanedCount} ä¸ªè¿‡æœŸæé†’æ˜ å°„`);
      }
      
      return cleanedCount;
    } catch (error) {
      const err = error as BusinessError;
      console.error(`æ¸…ç†è¿‡æœŸæé†’å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
      return 0;
    }
  }
  
  // å–æ¶ˆæ‰€æœ‰æé†’
  async cancelAllReminders(): Promise<void> {
    try {
      await reminderAgentManager.cancelAllReminders();
      this.reminderIds.clear();
      await this.saveReminderMappings();
      console.info('âœ… å–æ¶ˆæ‰€æœ‰æé†’æˆåŠŸ');
    } catch (error) {
      const err = error as BusinessError;
      console.error(`âŒ å–æ¶ˆæ‰€æœ‰æé†’å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
      throw new Error(`å–æ¶ˆæ‰€æœ‰æé†’å¤±è´¥: ${err.message}`);
    }
  }
  
  // æ£€æŸ¥æé†’æƒé™
  async checkReminderPermission(): Promise<boolean> {
    try {
      // æ£€æŸ¥é€šçŸ¥æƒé™
      const isNotificationEnabled = await notificationManager.isNotificationEnabled();
      if (!isNotificationEnabled) {
        console.warn('é€šçŸ¥æƒé™æœªå¼€å¯');
        return false;
      }
      
      // å°è¯•è·å–æœ‰æ•ˆæé†’æ¥æ£€æŸ¥æé†’æƒé™
      await this.getValidReminders();
      return true;
    } catch (error) {
      const err = error as BusinessError;
      console.error(`æé†’æƒé™æ£€æŸ¥å¤±è´¥ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
      return false;
    }
  }
  
  // æ‰¹é‡è®¾ç½®æé†’
  async batchSetReminders(events: CalendarEvent[]): Promise<BatchSetResult> {
    let successCount = 0;
    let failedCount = 0;
    
    for (const event of events) {
      try {
        await this.setEventReminder(event);
        successCount++;
      } catch (error) {
        const err = error as BusinessError;
        console.error(`æ‰¹é‡è®¾ç½®æé†’å¤±è´¥ - äº‹ä»¶: ${event.title}ï¼Œé”™è¯¯ç : ${err.code}, ä¿¡æ¯: ${err.message}`);
        failedCount++;
      }
    }
    
    console.info(`æ‰¹é‡è®¾ç½®æé†’å®Œæˆ: æˆåŠŸ ${successCount}, å¤±è´¥ ${failedCount}`);
    return { success: successCount, failed: failedCount } as BatchSetResult;
  }
}